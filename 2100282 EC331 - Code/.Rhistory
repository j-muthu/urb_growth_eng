) + c_21_rur_counterfact * (pop_21_rur_counterfact / tot_21_pop)
print(paste0("y_21_counterfactual: ", y_21_counterfactual))
# percentage change in income
pct_chg_y_tot = 100 * (y_21_counterfactual - y_21_baseline) / y_21_baseline
print(paste0("pct_chg_y_tot: ", pct_chg_y_tot))
### per-capita consumption (weighted by population) & %chg ####
# note consumption uses incumbent population that includes urban newcomers
# counterfactual
c_21_counterfactual = with(counterfactual_data_temp_marginal_city_calc,
sum(c_21_counterfact_loop * (pop_21_incumb_counterfact / tot_21_pop), na.rm = TRUE)
) + c_21_rur_counterfact * (pop_21_rur_incumb_counterfact / tot_21_pop)
print(paste0("c_21_counterfactual: ", c_21_counterfactual))
# percentage change in consumption
pct_chg_c_tot = 100 * (c_21_counterfactual - c_21_baseline) / c_21_baseline
print(paste0("pct_chg_c_tot: ", pct_chg_c_tot))
# generating variables for consumption as share of income (counterfactual)
cf_summed_c_y_vars = counterfactual_data_temp_marginal_city_calc %>%
summarise(
cf_c_all_cities_01 = sum(c_01),
cf_c_all_cities_21 = sum(c_21),
cf_y_all_cities_01 = sum(y_01),
cf_y_all_cities_21 = sum(y_21)
)
cf_c_ovr_y_01 <<- cf_summed_c_y_vars$cf_c_all_cities_01 / cf_summed_c_y_vars$cf_y_all_cities_01
print(paste0("cf_c_ovr_y_01: ", cf_c_ovr_y_01))
cf_c_ovr_y_21 <<- cf_summed_c_y_vars$cf_c_all_cities_21 / cf_summed_c_y_vars$cf_y_all_cities_21
print(paste0("cf_c_ovr_y_21: ", cf_c_ovr_y_21))
# always just 1 - (sigma + beta)/(gamma + theta)
# percentage changes for individual cities
counterfactual_data_temp_marginal_city_calc = counterfactual_data_temp_marginal_city_calc %>%
mutate(pct_chg_y = 100 * (y_21_counterfact_loop - y_21) / y_21) %>%
mutate(pct_chg_c = 100 * (c_21_counterfact_loop - c_21) / c_21) %>%
mutate(pct_chg_perm_rate = 100 * (perm_rate_counterfact - bua_perm_rate_01_21) / bua_perm_rate_01_21)
# Track results in global tibble
append_counterfactual_results(
sigma_f = sigma_f,
beta_f = beta_f,
gamma_f = gamma_f,
theta_f = theta_f,
lambda_f = lambda_f,
factor_change = factor_change,
factor_value = ifelse(factor_change, factor, percentile_75th_perm_rate),
cities_in_counterfactual_vector = cities_in_counterfactual_vector,
c_21_rur_counterfact = c_21_rur_counterfact,
rur_21_income = rur_21_income,
pop_21_rur_counterfact = pop_21_rur_counterfact,
pct_chg_pop_rur = pct_chg_pop_rur,
y_21_baseline = y_21_baseline,
c_21_baseline = c_21_baseline,
y_21_counterfactual = y_21_counterfactual,
pct_chg_y_tot = pct_chg_y_tot,
c_21_counterfactual = c_21_counterfactual,
pct_chg_c_tot= pct_chg_c_tot,
cf_c_ovr_y_01 = cf_c_ovr_y_01,
cf_c_ovr_y_21 = cf_c_ovr_y_21,
pct_chg_c_rur = pct_chg_c_rur
)
# Store results for this factor
cfact_fct_results_list[[as.character(factor)]] = list(
sigma_f = sigma_f,
beta_f = beta_f,
gamma_f = gamma_f,
theta_f = theta_f,
lambda_f = lambda_f,
counterfactual_data_temp_marginal_city_calc = counterfactual_data_temp_marginal_city_calc,
cities_in_counterfactual_vector = cities_in_counterfactual_vector,
c_21_rur_counterfact = c_21_rur_counterfact,
rur_21_income = rur_21_income,
pop_21_rur_counterfact = pop_21_rur_counterfact,
pct_chg_pop_rur = pct_chg_pop_rur,
y_21_baseline = y_21_baseline,
c_21_baseline = c_21_baseline,
y_21_counterfactual = y_21_counterfactual,
pct_chg_y_tot = pct_chg_y_tot,
c_21_counterfactual = c_21_counterfactual,
pct_chg_c_tot= pct_chg_c_tot,
cf_c_ovr_y_01 = cf_c_ovr_y_01,
cf_c_ovr_y_21 = cf_c_ovr_y_21,
pct_chg_c_rur = pct_chg_c_rur
)
### Store results in presentable table ####
#___________________________________________________________________________
presentable_table = counterfactual_data_temp_marginal_city_calc %>%
filter(in_counterfact == 1) %>%
select(c(BUA22NM,
pct_chg_perm_rate,
bua_21_pop,
bua_21_pop_counterfact,
pct_chg_y,
pct_chg_c
)) %>%
# dividing by 100 as excel/sheets, when formatting x into percentage,
# treats the conversion as 100x%
mutate(
pct_chg_perm_rate = pct_chg_perm_rate/100,
pct_chg_y = pct_chg_y/100,
pct_chg_c = pct_chg_c/100
) %>%
# add new column for increase in consumption of newcomers (formerly rural ppl)
mutate(pct_chg_c_newcomers = pct_chg_c_rur/100)
# Create a new row for rural areas
rural_row = tibble(
BUA22NM = "Rural areas",
pct_chg_perm_rate = NA,
bua_21_pop = rur_21_pop,
bua_21_pop_counterfact = pop_21_rur_counterfact,
pct_chg_y = pct_chg_c_rur/100,
pct_chg_c = NA,
pct_chg_c_newcomers = NA
)
# Combine the original table with the new row
presentable_table = bind_rows(presentable_table, rural_row)
# end of for loop through cost reduction factors
print(paste0("end of factor: ", factor))
# Save to global environment
if (store_results) {
if (factor_change) {
assign(
paste0(
"fact_",factor,
"_cf_",
length(cities_in_counterfactual_vector),"_cities_",
"_sb",(sigma_f+beta_f)*100,
"_gt",(gamma_f+theta_f)*100,
"_l",lambda_f*100),
cfact_fct_results_list,
envir = .GlobalEnv
)
assign(
paste0(
"tbl_fact_",factor,
"_cf_",
length(cities_in_counterfactual_vector),"_cities_",
"_sb",(sigma_f+beta_f)*100,
"_gt",(gamma_f+theta_f)*100,
"_l",lambda_f*100),
presentable_table,
envir = .GlobalEnv
)
write_csv(presentable_table,
paste0(
"Outputs/tbl_fact_",factor,
"_cf_",
length(cities_in_counterfactual_vector),"_cities_",
"_sb",(sigma_f+beta_f)*100,
"_gt",(gamma_f+theta_f)*100,
"_l",lambda_f*100,
".csv"
))
} else {
assign(
paste0(
"q75_cf_",
length(cities_in_counterfactual_vector),"_cities_",
"_sb",(sigma_f+beta_f)*100,
"_gt",(gamma_f+theta_f)*100,
"_l",lambda_f*100),
cfact_fct_results_list,
envir = .GlobalEnv
)
assign(
paste0(
"tbl_q75_cf_",
length(cities_in_counterfactual_vector),"_cities_",
"_sb",(sigma_f+beta_f)*100,
"_gt",(gamma_f+theta_f)*100,
"_l",lambda_f*100),
presentable_table,
envir = .GlobalEnv
)
write_csv(presentable_table,
paste0(
"Outputs/tbl_q75_cf_",
length(cities_in_counterfactual_vector),"_cities_",
"_sb",(sigma_f+beta_f)*100,
"_gt",(gamma_f+theta_f)*100,
"_l",lambda_f*100,
".csv"
))
}
}
}
# end of function
}
#_______________________________________________________________________________
# iterating over parameter values ####
# we can vary the parameters as robustness checks
# varying size of increase in permitting rate
perm_rate_change_factor = c(0.05,
0.1,
0.25,
0.3,
0.5)
# varying cities to be counterfactually evaluated
# cities to iterate over
cities_iteration = list(
agg_pop_01_11_21_ovr_city_threshold_rounded_rm_geog_constraints$BUA22NM[1:10],
agg_pop_01_11_21_ovr_city_threshold_rounded_rm_geog_constraints$BUA22NM[1:5], # top 5
agg_pop_01_11_21_ovr_city_threshold_rounded_rm_geog_constraints$BUA22NM[1:2], # top 2 (London, Birmingham)
agg_pop_01_11_21_ovr_city_threshold_rounded_rm_geog_constraints$BUA22NM[1], # london only
c("Greater London", "Oxford", "Cambridge (Cambridge)")
)
cities_in_counterfactual = cities_iteration[[1]]
# DP do:
# γ+θ = 0.09,0.11,0.13
# σ+β = 0.04,0.06,0.08
# note second order condition restrictions:
# γ + θ − σ − β > 0 and σ + β > 0
# using the same combinations as D+P
alt_parameter_options = tibble(
sigma_options = c(
0.02, 0.03, 0.04, 0.02, 0.03, 0.02, 0.03, 0.04
),
beta_options = c(
0.02, 0.03, 0.04, 0.02, 0.03, 0.02, 0.03, 0.04
),
gamma_options = c(
0.06, 0.06, 0.06, 0.07, 0.07, 0.08, 0.08, 0.08
),
theta_options = c(
0.03, 0.03, 0.03, 0.04, 0.04, 0.05, 0.05, 0.05
)
)
# Create a global tibble to store results
if (!exists("counterfactual_results_tibble")) {
counterfactual_results_tibble = tibble(
# Parameters
sigma = numeric(),
beta = numeric(),
gamma = numeric(),
theta = numeric(),
lambda = numeric(),
factor_change = logical(),
factor_value = numeric(),
cities_count = numeric(),
cities_list = list(),
# Results
c_21_rur_counterfact = numeric(),
rur_21_income = numeric(),
pop_21_rur_counterfact = numeric(),
pct_chg_pop_rur = numeric(),
y_21_baseline = numeric(),
c_21_baseline = numeric(),
y_21_counterfactual = numeric(),
pct_chg_y_tot = numeric(),
c_21_counterfactual = numeric(),
pct_chg_c_tot= numeric(),
cf_c_ovr_y_01 = numeric(),
cf_c_ovr_y_21 = numeric(),
pct_chg_c_rur = numeric()
)
}
# Function to append results to global tibble
append_counterfactual_results = function(
sigma_f,
beta_f,
gamma_f,
theta_f,
lambda_f,
factor_change,
factor_value,
cities_in_counterfactual_vector,
c_21_rur_counterfact,
rur_21_income,
pop_21_rur_counterfact,
pct_chg_pop_rur,
y_21_baseline,
c_21_baseline,
y_21_counterfactual,
pct_chg_y_tot,
c_21_counterfactual,
pct_chg_c_tot,
cf_c_ovr_y_01,
cf_c_ovr_y_21,
pct_chg_c_rur
) {
# Create new row
new_row = tibble(
sigma = sigma_f,
beta = beta_f,
gamma = gamma_f,
theta = theta_f,
lambda = lambda_f,
factor_change = factor_change,
factor_value = factor_value,
cities_count = length(cities_in_counterfactual_vector),
cities_list = list(cities_in_counterfactual_vector),
c_21_rur_counterfact = c_21_rur_counterfact,
rur_21_income = rur_21_income,
pop_21_rur_counterfact = pop_21_rur_counterfact,
pct_chg_pop_rur = pct_chg_pop_rur,
y_21_baseline = y_21_baseline,
c_21_baseline = c_21_baseline,
y_21_counterfactual = y_21_counterfactual,
pct_chg_y_tot = pct_chg_y_tot,
c_21_counterfactual = c_21_counterfactual,
pct_chg_c_tot= pct_chg_c_tot,
cf_c_ovr_y_01 = cf_c_ovr_y_01,
cf_c_ovr_y_21 = cf_c_ovr_y_21,
pct_chg_c_rur = pct_chg_c_rur
)
# Append to global tibble
counterfactual_results_tibble <<- bind_rows(counterfactual_results_tibble, new_row)
# Print basic results
message(sprintf("Row added to results tibble: σ+β=%.2f, γ+θ=%.2f, cities=%d",
sigma_f+beta_f, gamma_f+theta_f, length(cities_in_counterfactual_vector)))
message(paste0("Consumption change: ", pct_chg_c_rur))
return(invisible(NULL))
}
#_______________________________________________________________________________
## main parameter options - DP's original ####
data_for_cf_fn(
og_dataset = agg_pop_01_11_21_ovr_city_threshold_rounded_rm_geog_constraints,
cities_in_counterfactual_f = cities_in_counterfactual,
beta_f = beta_usa,
gamma_f = gamma_usa,
lambda_f = lambda_usa,
sigma_f = sigma_usa,
theta_f = theta_usa
)
write_csv(start_counterfactual_data,
"Outputs/dp_original_params_counterfactual_data.csv")
dp_original_params_counterfactual_data = start_counterfactual_data
counterfactual_function(
counterfactual_dataset = start_counterfactual_data,
cities_in_counterfactual_vector = cities_in_counterfactual,
perm_rate_change_factor_vector = perm_rate_change_factor,
beta_f = beta_usa,
gamma_f = gamma_usa,
lambda_f = lambda_usa,
sigma_f = sigma_usa,
theta_f = theta_usa,
# whether we're changing based on the factor list or not
# if not, we increase permitting rates up to the 75th percentile value
factor_change = FALSE,
# save results to global environment?
store_results = TRUE
)
#_______________________________________________________________________________
## original parameters - varying cities ####
for (i in cities_iteration) {
data_for_cf_fn(
og_dataset = agg_pop_01_11_21_ovr_city_threshold_rounded_rm_geog_constraints,
cities_in_counterfactual_f = i,
beta_f = beta_usa,
gamma_f = gamma_usa,
lambda_f = lambda_usa,
sigma_f = sigma_usa,
theta_f = theta_usa
)
counterfactual_function(
counterfactual_dataset = start_counterfactual_data,
cities_in_counterfactual_vector = i,
perm_rate_change_factor_vector = perm_rate_change_factor,
beta_f = beta_usa,
gamma_f = gamma_usa,
lambda_f = lambda_usa,
sigma_f = sigma_usa,
theta_f = theta_usa,
# whether we're changing based on the factor list or not
# if not, we increase permitting rates up to the 75th percentile value
factor_change = FALSE,
# save results to global environment?
store_results = TRUE
)
}
#_______________________________________________________________________________
## original parameters - using cost reduction factors ####
data_for_cf_fn(
og_dataset = agg_pop_01_11_21_ovr_city_threshold_rounded_rm_geog_constraints,
cities_in_counterfactual_f = cities_in_counterfactual,
beta_f = beta_usa,
gamma_f = gamma_usa,
lambda_f = lambda_usa,
sigma_f = sigma_usa,
theta_f = theta_usa
)
counterfactual_function(
counterfactual_dataset = start_counterfactual_data,
cities_in_counterfactual_vector = cities_in_counterfactual,
perm_rate_change_factor_vector = perm_rate_change_factor,
beta_f = beta_usa,
gamma_f = gamma_usa,
lambda_f = lambda_usa,
sigma_f = sigma_usa,
theta_f = theta_usa,
# whether we're changing based on the factor list or not
# if not, we increase permitting rates up to the 75th percentile value
factor_change = TRUE,
# save results to global environment?
store_results = TRUE
)
#_______________________________________________________________________________
## varying sigma, beta, gamma, theta #####
for (param_idx in 1:nrow(alt_parameter_options)) {
# adjusting parameters
gamma = alt_parameter_options$gamma_options[param_idx]
theta = alt_parameter_options$theta_options[param_idx]
sigma = alt_parameter_options$sigma_options[param_idx]
beta = alt_parameter_options$beta_options[param_idx]
data_for_cf_fn(
og_dataset = agg_pop_01_11_21_ovr_city_threshold_rounded_rm_geog_constraints,
cities_in_counterfactual_f = cities_in_counterfactual,
beta_f = beta,
gamma_f = gamma,
lambda_f = lambda_usa,
sigma_f = sigma,
theta_f = theta
)
counterfactual_function(
counterfactual_dataset = start_counterfactual_data,
cities_in_counterfactual_vector = cities_in_counterfactual,
perm_rate_change_factor_vector = perm_rate_change_factor,
beta_f = beta,
gamma_f = gamma,
lambda_f = lambda_usa,
sigma_f = sigma,
theta_f = theta,
# whether we're changing based on the factor list or not
# if not, we increase permitting rates up to the 75th percentile value
factor_change = FALSE,
# save results to global environment?
store_results = TRUE
)
}
# viewing final results
view(counterfactual_results_tibble)
# consumption as share of income
# https://www.perplexity.ai/search/consumption-as-share-of-income-My2BWGVtQGiqmyN8TRgE6g
# https://ifs.org.uk/publications/measuring-living-standards-income-and-consumption-evidence-uk-1
# https://www.stats.gov.cn/english/PressRelease/202410/t20241025_1957142.html
# https://www.bea.gov/system/files/papers/BEA-WP2023-1.pdf
# replicating results of DP's original paper ####
## plots ####
top_10_buas = dp_original_params_counterfactual_data %>%
arrange(desc(bua_21_pop)) %>%
slice_head(n = 10)
perm_rate_vs_city_pop = ggplot(dp_original_params_counterfactual_data,
aes(x = bua_21_pop, y = 1/bua_perm_rate_01_21)) +
geom_point(alpha = 0.5) +
geom_smooth(method = "lm", color = "blue", se = F) +
geom_text_repel(
data = top_10_buas,
aes(label = BUA22NM),
size = 3.5,
box.padding = 0.5,
point.padding = 0.2,
force = 10
) +
labs(
# title = "Planning regulations and city population",
x = "2021 population (log scale)",
y = "Reciprocal of permitting rate \n(2001-2021)"
) +
theme_minimal() +
scale_x_log10()
geog_constr_vs_perm_rate = ggplot(dp_original_params_counterfactual_data,
aes(x = 1 - 1/geographic_constraint, y = 1/bua_perm_rate_01_21)) +
geom_point(alpha = 0.5) +
geom_smooth(method = "lm", color = "blue", se = F) +
geom_text_repel(
data = top_10_buas,
aes(label = BUA22NM),
size = 3.5,
box.padding = 0.5,
point.padding = 0.2,
force = 10
) +
labs(
# title = "Planning regulations and geographical constraints",
x = "Estimated % geographically-constrained land (log scale)",
y = "Reciprocal of permitting rate \n(2001-2021)"
) +
theme_minimal() +
scale_x_log10(labels = scales::percent)
print(perm_rate_vs_city_pop)
print(geog_constr_vs_perm_rate)
ggsave("Outputs/perm_rate_vs_city_pop.png",
perm_rate_vs_city_pop,
units = "cm",
width = 16,
height = 12,
dpi = 320)
ggsave("Outputs/geog_constr_vs_perm_rate.png",
geog_constr_vs_perm_rate,
units = "cm",
width = 16,
height = 12,
dpi = 320)
## regressions ####
# Permitting rate vs log population
perm_rate_vs_city_pop_reg = lm(I(1/bua_perm_rate_01_21) ~ log(bua_21_pop), data = dp_original_params_counterfactual_data)
# Permitting rate vs log share of geographically constrained land
geog_constr_vs_perm_rate_reg = lm(I(1/bua_perm_rate_01_21) ~ log(1 - 1/geographic_constraint), data = dp_original_params_counterfactual_data)
# outputting models
summary_perm_rate_vs_city_pop_reg = summary(perm_rate_vs_city_pop_reg)
summary_geog_constr_vs_perm_rate_reg = summary(geog_constr_vs_perm_rate_reg)
summary_perm_rate_vs_city_pop_reg
summary_geog_constr_vs_perm_rate_reg
# creating latex table
stargazer(perm_rate_vs_city_pop_reg,
geog_constr_vs_perm_rate_reg,
title = "Empirically testing model predictions",
# column.labels = c("Log 2021 Population", "Log Geographic Constraint"),
column.separate = c(1, 1),
dep.var.labels = "Reciprocal of permitting rate (2001-2021)",
covariate.labels = c("Log population", "Log \\% of geographically constrained land", "Constant"),
align = TRUE,
model.numbers = TRUE,
label = "tab:reg tab",
type = "latex",
out = "Outputs/regression_results.tex")
